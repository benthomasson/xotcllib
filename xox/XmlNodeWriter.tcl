
package require tdom

namespace eval xox {

   ::xotcl::Class XmlNodeWriter 

   XmlNodeWriter # XmlNodeWriter {

       Library of methods to write XML from a tree of ::xox::Nodes.

       The primary methods in this library are writeXmlFile and generateXml.
   }

   XmlNodeWriter # dom { The DOM object that is currently being created by generateXml }
   XmlNodeWriter # rootNode { The root ::xox::Node that is being written to XML }

   XmlNodeWriter parameter { 
       dom
       rootNode 
   }

   XmlNodeWriter # writeXmlFile {

       Writes an XML representation of a tree of ::xox::Nodes to a file
       named fileName.

       Returns: 

       The xml written to the file.
   }

   XmlNodeWriter instproc writeXmlFile { node fileName } {

       set file [ open $fileName w ]
       set xml  [ my generateXml $node ]
       puts $file $xml
       flush $file
       close $file

       return $xml
   }

   XmlNodeWriter # generateXml {

        Generates XML from a tree of ::xox::Nodes.

        Arguments:

        node - The root of a tree of ::xox::Nodes.

        Returns:
        
        The xml generated.
   }

   XmlNodeWriter instproc generateXml { node } {

       my instvar rootNode dom

       set rootNode $node

       set dom [ dom createDocument [ my getTagFromClass [ $node info class ] ] ]
       set root [ $dom documentElement ]

       global env

       set comment [ $dom createComment "Generated by [ my info class ] $env(USER) at [ clock format [ clock seconds ] ]" ]
       my buildXml $root $node

       return \
"[ $comment asXML ]
[ $root asXML ]"
   }

   XmlNodeWriter instproc generateQuickXml { node } {

       my instvar rootNode dom

       set rootNode $node

       set dom [ dom createDocument [ my getTagFromClass [ $node info class ] ] ]
       set root [ $dom documentElement ]

       my buildXml $root $node

       return [ $root asXML ]
   }

   XmlNodeWriter # buildVariable {

       Creates the DOM nodes needed to represent the variable and values
       of a variable on a ::xox::Node.

       Arguments:

       parentDomNode - The parent DOM node to create the new DOM nodes under.
       node - A reference to the ::xox::Node that has the variable, variable.
       variable - The variable name.
   }

   XmlNodeWriter instproc isTemporary { object } {

       return [ string match ::xotcl::__#* $object ]
   }

   XmlNodeWriter instproc buildVariable { parentDomNode node variable } {

       my instvar dom

       set value [ $node set $variable ]

       regsub -all {&} $value { } value

       if { "" == "$value" } {

           my buildVariableXml $parentDomNode ${variable} $value
           return 
       }

       catch {
           set object ""
           set object [ lindex $value 0 ]
       }
       if [ uplevel #0 [ list ::xotcl::Object isclass $object ] ] {

         my buildVariableXml $parentDomNode ${variable} $value
           
       } elseif [ uplevel #0 [ list ::xotcl::Object isobject $object ] ] {

           #my debug $object

           if [ my isTemporary $object ] {
               return
           }
           my buildVariableXml $parentDomNode ${variable} $value

       } else {
           my buildVariableXml $parentDomNode ${variable} $value 
       }
   }

   XmlNodeWriter # buildArrayVariable {

       Creates the DOM nodes needed to represent an array variable on an ::xox::Node.

       Arguments:

       parentDomNodea - the DOM node to create the new DOM nodes under.
       node - The ::xox::Node that holds the variable, variable.
       variable - The name of the variable to convert to XML DOM.
   }

   XmlNodeWriter instproc buildArrayVariable { parentDomNode node variable } {

       if { "nameToNodes" == "$variable" } { return }
       if { "#" == "$variable" } { return }

       foreach name [ $node array names $variable ] {

           if [ my isobject $name ] {

               if [ my isTemporary $name ] {
                   return
               }
           }

           set value [ $node set ${variable}($name) ]

           if { "" == "$value" } { 
               
               my buildArrayVariableXml $parentDomNode ${variable} $value $name 
               continue 
           }

           if [ Object isclass [ lindex $value 0 ] ] {

               my buildArrayVariableXml $parentDomNode ${variable} $value $name

           } elseif [ Object isobject [ lindex $value 0 ] ] {
               if [ my isTemporary [ lindex $value 0 ] ] {
                   continue
               }
               my buildArrayVariableXml $parentDomNode ${variable} $value $name
           } else {

               my buildArrayVariableXml $parentDomNode ${variable} $value $name
           }
       }
   }

   XmlNodeWriter # buildVariableXml {

       Creates a new DOM node as a child of parentDomNode that represents
       the variable and value of a variable on a ::xox::Node.

       Creates a new DOM node with the name of the name of the variable.  The text
       value of the DOM node is the value of the variable.

       Optionally the variable DOM node may have a valueType. This may be the value: path or paths.
       Path and paths valueTypes are used to denote that the value is a path to an object in
       the ::xox::Node tree.

       Arguments:

       parentDomNode - the DOM node to create the new DOM nodes under.
       variable - The name of the variable to convert to XML DOM.
       value - The value of the variable.
       valueType - The type of value in the value node.
   }

   XmlNodeWriter instproc buildVariableXml { parentDomNode variable value { valueType "" } } {

       my instvar dom

       set variableNode [ $dom createElement $variable  ]
       set valueText [ $dom createCDATASection $value ]

       if { "$valueType" != "" } {
           $variableNode setAttribute type $valueType
       }

       $variableNode appendChild $valueText
       $parentDomNode appendChild $variableNode
   }

   XmlNodeWriter # buildArrayVariableXml {

       Arguments:

       parentDomNode - the DOM node to create the new DOM nodes under.
       variable - The name of the variable to convert to XML DOM.
       value - The value of the variable.
       index - The key of the value in the array.
       indexType - The type of value in the index node.
       valueType - The type of value in the value node.
   }

   XmlNodeWriter instproc buildArrayVariableXml { parentDomNode variable value index } {

       my instvar dom

       set variableNode [ $dom createElement $variable  ]
       set valueText [ $dom createCDATASection $value ]

       $variableNode setAttribute type array

       set indexNode [ $dom createElement index  ]
       set indexText [ $dom createCDATASection $index ]

       set valueNode [ $dom createElement value  ]
       set valueText [ $dom createCDATASection $value ]

       $variableNode appendChild $indexNode
       $variableNode appendChild $valueNode

       $indexNode appendChild $indexText
       $valueNode appendChild $valueText

       $parentDomNode appendChild $variableNode
   }

   XmlNodeWriter # buildMixinXml {

       Creates an DOM node that has the type="mixin" to denote that
       the value of the DOM node is a mixin.  

       Arguments:
       
       parentDomNode - The parent DOM node to create the new DOM node under.
       mixin - The Class to specify as a mixin in the value of the new DOM node.
   }

   XmlNodeWriter instproc buildMixinXml { parentDomNode mixin } {

       my instvar dom

       set mixinNode [ $dom createElement mixin  ]
       set mixinText [ $dom createCDATASection $mixin ]
       $mixinNode setAttribute type mixin

       $mixinNode appendChild $mixinText
       $parentDomNode appendChild $mixinNode
   }

   XmlNodeWriter # buildXml {

       Recursive call that builds the XML from a subtree of ::xox::Nodes.

       buildXml creates DOM nodes that represent all the variables, array
       variables, mixins, and child nodes for this subtree starting with node.
   }

   XmlNodeWriter instproc buildXml { parentDomNode node } {

       my instvar dom

       my buildVariableXml $parentDomNode nodeName [ $node getNodeName ]

       foreach mixin [ lsort [ $node info mixin ] ] {

           my buildMixinXml $parentDomNode $mixin
       }

       foreach var [ lsort [ $node info vars ] ] {

           if { "$var" == "#" } { continue }
           if { "$var" == "nodeName" } { continue }
           if { "$var" == "parentNode" } { continue }
           if { "$var" == "__autonames" } { continue }

           if [ $node array exists $var ] {

               my buildArrayVariable $parentDomNode $node $var

           } else {

               my buildVariable $parentDomNode $node $var
          }
       }

       foreach subElement [ $node nodes ] {

           if [ $subElement hasclass ::xox::Node ] {

               my buildNodeXml $parentDomNode $subElement
           }
       }
    }

    XmlNodeWriter # buildNodeXml {

        Builds the xml for a node.  This creates a new DOM node
        with the name of the class of the ::xox::Node and appends
        that as a child of parentDomNode.

        Arguments:

        parentDomNode - the parent of the new DOM node. 
        node - the ::xox::Node instance to build XML for.
    }

    XmlNodeWriter instproc buildNodeXml { parentDomNode node } {

        my instvar dom

           set tdomNode [ $dom createElement [ my getTagFromClass [ $node info class ]  ] ]
           $parentDomNode appendChild $tdomNode
           my buildXml $tdomNode $node 
    }

    XmlNodeWriter # checkIsNotNode {

        Checks if item is not a Node. 

        Returns:

        1 - if item is not a Node.
        0 - if item is a Node instance.
    }

    XmlNodeWriter instproc checkIsNotNode { item } {

        if { ! [ Object isobject $item ] } { return 1 }

        if { [ $item hasclass ::xotcl::Class ] } {

            return 1
        }

        if { ! [ $item hasclass ::xox::Node ] } {

           puts "Warning: $item is a [ $item info class ]"
           return 1
        }
        return 0
    }

    XmlNodeWriter instproc getTagFromClass { class } {

        set tag [ regsub -all :: $class : ]

        if [ ::xox::startsWith $tag : ] {

            return [ string range $tag 1 end ]
        } else {

            return $tag
        }
    }

    XmlNodeWriter instproc getTagFromNode { node } {

        return [ my getTagFromClass [ $node info class ] ]
    }

    XmlNodeWriter instproc buildDTD { rootNode } {

        my instvar defined

        set defined ""

        set dtd ""

        append dtd "<!DOCTYPE [ my getTagFromNode $rootNode ] \[\n"
        append dtd [ my buildDTDFromNode $rootNode ] 
        append dtd "\] >\n"

        return $dtd
    }

    XmlNodeWriter instproc buildDTDFromNode { node } {

        my instvar defined

        set dtd ""

        append dtd "<!ELEMENT [ my getTagFromNode $node ] [ my buildDTDChildren $node ] >\n"

        foreach var [ my getVarsAndParameters $node ] {

            if { [ lsearch -exact $defined $var ] != -1 } { continue }

            if { "$var" == "#" } { continue }
            if { "$var" == "nodeName" } { continue }
            if [ ::xox::startsWith $var _ ] { continue }

            lappend defined $var

            append dtd "<!ELEMENT $var (#PCDATA) >\n"
        }

        foreach child [ $node nodes ] {

            if { [ lsearch -exact $defined [ $child info class ] ] != -1 } { continue }

            lappend defined [ $child info class ]

            append dtd [ my buildDTDFromNode $child ]
        }

        return $dtd
    } 

    XmlNodeWriter instproc getVarsAndParameters { node } {

        set parameters [ ::xox::mapcar {

            lindex $pair 0
        } pair [ ::xox::ObjectGraph allClassParameters [ $node info class ] ] ]
        return [ lsort -unique [ concat [ $node info vars ] $parameters  ] ]
    }

    XmlNodeWriter instproc buildDTDChildren { node } {

        set lastChild ""

        set children ""

        foreach var [ my getVarsAndParameters $node ] {

            if { "#" == "$var" } {continue}
            if { "nodeName" == "$var" } {continue}
            if [ ::xox::startsWith $var _ ] { continue }

            lappend children "${var}*"
        }

        foreach child [ $node nodes ] {

            if { "$lastChild" == "[ $child info class ]" } { continue }

            lappend children "[ my getTagFromNode $child ]*"

            set lastChild [ $child info class ]
        }

        if { "" == "$children" } {

            return EMPTY
        }

        return "([ join $children , ])"
    }
}


